Tree\95. Unique Binary Search Trees II(Med).py
**如何用一串数字构建出所有独特的BST

Tree\96. Unique Binary Search Trees(Med).py
**计算一串数字构建出所有独特BST到底有多少个
https://www.youtube.com/watch?v=Ox0TenN3Zpg&ab_channel=NEETcode

Tree\98. Validate Binary Search Tree(Med).py
**验证BST

101. Symmetric Tree(Easy).py

104. Maximum Depth of Binary Tree(Easy).py

Tree\105. Construct Binary Tree from Preorder and Inorder Traversal(Med).py
Tree\106. Construct Binary Tree from Inorder and Postorder Traversal(Med).py
**如何用preorder，inorderr和inorder，postorder构建出一颗完整的二叉树
我做出来了，但是还是要注意一下。
思路其实就是从preorder/postorder pop出一个root
然后用这个root在inoder里面分成左右两组代表这个root的左子叶和右子叶。
一直循环到pop空preorder/postorder位置。

107. Binary Tree Level Order Traversal II(Med).py

110. Balanced Binary Tree(Easy).py

111. Minimum Depth of Binary Tree(Easy).py

Tree\114. Flatten Binary Tree to Linked List(Med).py
用DFS做

Tree\116. Populating Next Right Pointers in Each Node(Med).py
Tree\117. Populating Next Right Pointers in Each Node II(Med).py
BFS！！！！！！！！

226. Invert Binary Tree(Easy).py
镜像二叉树，要看

235. Lowest Common Ancestor of a Binary Search Tree(Easy).py
找节点，可以看看
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/

Tree\538. Convert BST to Greater Tree(Easy).py

认真学习self的用法还有递归

Tree\572. Subtree of Another Tree(Easy).py
思路，使用preorder遍历，但是有null的子叶要记录下来避免出现误差和错误

Tree\559. Maximum Depth of N-ary Tree(Easy).py
思路：一样使用preorder遍历，然后只要下一个有child就+1，比较麻烦的不是二叉树，所以直接
for一遍所有的子叶就可以了。

Tree\606. Construct String from Binary Tree(Easy).py

Tree\617. Merge Two Binary Trees(Easy).py

Tree\669. Trim a Binary Search Tree(Easy).py

#重点是记住BST，左子叶 < 根 < 右子叶 就很好理解了。

Tree\687. Longest Univalue Path(Easy).py
#递归的处理

Tree\897. Increasing Order Search Tree(Easy).py
构建树



