class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas) < sum(cost):
            return -1;

        n = len(gas)
        tank = 0
        start = 0
        
        for i in range(n):
            tank += gas[i]-cost[i]
            
            if tank < 0:
                start = i+1
                tank = 0
                
        return start if start < n else -1

# 贪心：
# 一个转圈的问题
# 因为他要寻找一个能完整转圈的答案，那么首先确保总损耗小于等于总油量
# 如果损耗多于油量那肯定跑不完，-1.
# 然后建立一个开始点记录开始的点能跑完一圈的。
# 然后有一个tank表示从start点开始一路开过来的剩余油量
# 如果大于等于0那么表示从start点开到现在能继续开下去
# 如果小于0，那么start就要改变，从下一个加油站开始
# 因为如果小于0，那么从start点到这个归0的点中间任何一个起点作为起点都没用
# 因为你在继承前一个剩余油量为大于等于0的情况下到下一个加油站还是负数，说明
# 你中间那一堆怎么移动最后到那个点都是负数的。、
# 比如你剩余油量是这么一个过程
# 站点： 1 2 3
# 油量： 4 5 -2 .... 
# 那么你就算把起始点移动到2，那么你到下一站肯定还是负数，因为你从站点1开始的时候
# 到站点2的时候是5，那么从站点5开始只能是小于等于5，那么到3的时候肯定是大于等于
# -2
# 所以要推到下一个。
# 当遍历完后，保存的start就是起点，如果起点大于n那么表示走不完。